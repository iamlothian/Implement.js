Function.prototype.Implement = function() {
    "use strict";
    var implementContext = Object.prototype.toString.call(this) === "[object Function]" && this.name !== "Function" ? this : null, implamentList = Array.prototype.slice.call(arguments, 0), isNativeCode = function(constructor) {
        return constructor.toString().split(/[\{\}]/g)[1] === " [native code] " && Object.prototype.toString.call(constructor) === "[object Function]" && constructor.name !== "Function";
    }, compile = function(capture_args, implementContext) {
        var implaments = [], _protected = null, __private = null;
        if (!!implementContext) {
            implaments.unshift(implementContext);
            capture_args.unshift(implementContext);
        }
        for (var arg in capture_args) {
            if (capture_args.hasOwnProperty(arg)) {
                var fn, thisArgs;
                switch (Object.prototype.toString.call(capture_args[arg])) {
                  case "[object Function]":
                    fn = capture_args[arg];
                    break;

                  case "[object Array]":
                    fn = capture_args[arg][0];
                    thisArgs = capture_args[arg].slice(1);
                    break;
                }
                fn.apply(this, thisArgs);
                __private = _protected;
                _protected = this._protected;
                delete this._protected;
                for (var method_signiture in fn.prototype) {
                    (function(fn_p) {
                        this.constructor.prototype[method_signiture] = function(_protected) {
                            return function() {
                                return fn_p.call(this, _protected, __private);
                            };
                        };
                    }).call(this, fn.prototype[method_signiture]);
                }
                implaments.push(fn);
            }
        }
        for (var proto_method_signiture in this.constructor.prototype) {
            this.constructor.prototype[proto_method_signiture] = this.constructor.prototype[proto_method_signiture](_protected);
        }
        this.__isInstanceOf__ = function(constructor) {
            var pass = false || constructor.name === "Function" && constructor.prototype.name === "Empty" || typeof constructor === "function" && implaments.indexOf(constructor) >= 0;
            return pass;
        };
        this.Extend = function() {
            var _base = isNativeCode(capture_args[0]) ? capture_args[0] : Function;
            var obj = Function.Implement.apply(_base, [].concat(capture_args, Array.prototype.slice.call(arguments, 0)));
            var extending = implaments;
            var base__isInstanceOf__ = obj.__isInstanceOf__;
            obj.__isInstanceOf__ = function(constructor) {
                return false || Object.prototype.toString.call(constructor) === "[object Object]" && !!constructor.__isInstanceOf__ && function() {
                    for (var imp in extending) {
                        if (!constructor.__isInstanceOf__(extending[imp])) {
                            return false;
                        }
                    }
                    return true;
                }() || base__isInstanceOf__(constructor);
            };
            return obj;
        };
        delete this.__safe__;
        return this;
    };
    var base;
    if (isNativeCode(this)) {
        base = new this();
    } else {
        base = {
            __safe__: true
        };
    }
    return compile.call(base, implamentList, implementContext);
};
//# sourceMappingURL=Implement.min.map